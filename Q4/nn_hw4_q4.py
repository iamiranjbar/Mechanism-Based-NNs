# -*- coding: utf-8 -*-
"""NN HW4 Q4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vnf0chjAQvn6AdIwAV2n-_euZCIXTMCM

# Question 4 (Hamming Net)

## Hamming Net network implementation

### Implement MaxNet for second layer of hamming net
"""

class MaxNet:
  
  def __init__(self, values, epsilon, t_max=10):
    self.initial_values = values.copy()
    self.old_values = values.copy()
    self.values = values.copy()
    self.epsilon = epsilon
    self.t_max = t_max
  
  def activate(self, x):
    if x >= 0:
      return x
    return 0
  
  def update(self):
    old_values_sum = sum(self.old_values)
    for index in range(len(self.values)):
      self.values[index] = self.activate(self.old_values[index] - self.epsilon * 
                                         (old_values_sum - self.old_values[index]))
    self.old_values = self.values
  
  def is_stopped(self):
    non_zero_count = sum(element !=0 for element in self.values)
    return non_zero_count == 1
  
  def print_values(self):
    print(*self.values)

  def max_indices(self):
    max_indices = []
    for index in range(len(self.values)):
      if self.values[index] != 0:
        max_indices.append(index)
    return max_indices
  
  def find_max_index(self, verbose=False):
    if verbose:
      print("Initial values:")
      self.print_values()
    iteration_count = 0

    while not self.is_stopped():
      iteration_count += 1
      self.update()
      if verbose:
        print(f"Iteration {iteration_count} values:")
        self.print_values()
      
      if iteration_count == self.t_max:
        break
    
    return self.max_indices()

"""### HammingNet class implementation"""

class HammingNet:

  def __init__(self, base_vectors):
    self.base_vectors = base_vectors
    self.weights = self.create_weight_matrix()
    self.bias = self.create_bias()
  
  def create_weight_matrix(self):
    weight_matrix = []
    for input_index in range(len(self.base_vectors[0])):
      weight_matrix.append([])
      for vector in self.base_vectors:
        weight_matrix[input_index].append(vector[input_index]/2)
    return weight_matrix

  def create_bias(self):
    input_dimension = len(self.base_vectors[0])
    bias = [input_dimension/2 for _ in range(len(self.base_vectors))]
    return bias

  def calculate_y_in(self, input):
    y_in = [0 for _ in range(len(self.base_vectors))]
    for j in range(len(y_in)):
      weighted_sum = 0
      for i in range(len(input)):
        weighted_sum += (input[i] * self.weights[i][j])
      y_in[j] = self.bias[j] + weighted_sum
    return y_in
  
  def get_most_similiar_vector(self, input, verbose=False):
    y_in = self.calculate_y_in(input)

    if verbose:
      print("Input:")
      print(input)
      for base_vector_index in range(len(self.base_vectors)):
        print("Base vector:")
        print(self.base_vectors[base_vector_index])
        print(f"Similiarity: {y_in[base_vector_index]}")
        print("==============================")

    epsilon = 0.13
    max_net = MaxNet(y_in, epsilon)
    max_indices = max_net.find_max_index()
    if len(max_indices) == 1:
      return self.base_vectors[max_indices[0]]
    else:
      return [self.base_vectors[index] for index in max_indices]

"""## Test HammingNet for given vectors"""

base_vector_1 = [1, -1, 1, -1, 1, -1]
base_vector_2 = [-1, 1, -1, 1, -1, -1]
base_vector_3 = [1, 1, 1, -1, -1, -1]
base_vectors = [base_vector_1, base_vector_2, base_vector_3]

hamming_net = HammingNet(base_vectors)

test_vector_1 = [1, 1, 1, 1, 1, 1]
test_vector_2 = [-1, 1, -1, -1, 1, 1]
test_vector_3 = [-1, -1, 1, 1, 1, 1]
test_vector_4 = [-1, -1, 1, 1, -1, 1]
test_vector_5 = [-1, 1, 1, -1, -1, -1]
test_vectors = [test_vector_1, test_vector_2, test_vector_3, 
                test_vector_4, test_vector_5]

for vector in test_vectors:

  most_similiar_vector = hamming_net.get_most_similiar_vector(vector)

  print("Main vector:")
  print(vector)
  print("Most similiar vector(s):")
  print(most_similiar_vector)
  print("_______________________________")